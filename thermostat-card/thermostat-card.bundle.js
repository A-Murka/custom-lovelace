/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/thermostat-card.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/index.js!./src/thermostat.lib.css":
/*!**********************************************************!*\
  !*** ./node_modules/css-loader!./src/thermostat.lib.css ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \".dial_container {\\n  padding: 8px;\\n}\\n.dial_title {\\n  font-size: 20px;\\n  padding: 8px;\\n  text-align: center;\\n  color: var(--secondary-text-color);\\n}\\n.dial {\\n  user-select: none;\\n\\n  --thermostat-off-fill: #222;\\n  --thermostat-path-color: rgba(255, 255, 255, 0.3);\\n  --thermostat-heat-fill: #E36304;\\n  --thermostat-cool-fill: #007AF1;\\n  --thermostat-path-active-color: rgba(255, 255, 255, 0.8);\\n  --thermostat-path-active-color-large: rgba(255, 255, 255, 1);\\n  --thermostat-text-color: white;\\n}\\n.dial.has-thermo .dial__ico__leaf {\\n  visibility: hidden;\\n}\\n.dial .dial__shape {\\n  transition: fill 0.5s;\\n}\\n.dial__ico__leaf {\\n  fill: #13EB13;\\n  opacity: 0;\\n  transition: opacity 0.5s;\\n  pointer-events: none;\\n}\\n.dial__ico__settings {\\n  fill: var(--thermostat-off-fill);\\n  opacity: 0;\\n  transition: opacity 0.5s;\\n}\\n.dial.has-leaf .dial__ico__leaf {\\n  display: block;\\n  opacity: 1;\\n  pointer-events: initial;\\n}\\n.dial__ico__thermo {\\n  fill: var(--thermostat-path-active-color);\\n  opacity: 0;\\n  transition: opacity 0.5s;\\n  pointer-events: none;\\n}\\n.dial.has-thermo .dial__ico__thermo {\\n  display: block;\\n  opacity: 1;\\n  pointer-events: initial;\\n}\\n.dial__editableIndicator {\\n  fill: white;\\n  fill-rule: evenodd;\\n  opacity: 0;\\n  transition: opacity 0.5s;\\n}\\n.dial__temperatureControl {\\n  fill: white;\\n  opacity: 0;\\n  transition: opacity 0.2s;\\n}\\n.dial__temperatureControl.control-visible {\\n  opacity: 0.2;\\n}\\n.dial--edit .dial__editableIndicator {\\n  opacity: 1;\\n}\\n.dial--state--off .dial__shape {\\n  fill: var(--thermostat-off-fill);\\n}\\n.dial--state--heat .dial__shape {\\n  fill: var(--thermostat-heat-fill);\\n}\\n.dial--state--cool .dial__shape {\\n  fill: var(--thermostat-cool-fill);\\n}\\n.dial__ticks path {\\n  fill: var(--thermostat-path-color);\\n}\\n.dial__ticks path.active {\\n  fill: var(--thermostat-path-active-color);\\n}\\n.dial__ticks path.active.large {\\n  fill: var(--thermostat-path-active-color-large);\\n}\\n.dial text, .dial text tspan {\\n  fill: var(--thermostat-text-color);\\n  text-anchor: middle;\\n  font-family: Helvetica, sans-serif;\\n  alignment-baseline: central;\\n}\\n.dial__lbl--target {\\n  font-size: 120px;\\n  font-weight: bold;\\n  visibility: hidden;\\n}\\n.dial__lbl--low, .dial__lbl--high {\\n  font-size: 90px;\\n  font-weight: bold;\\n  visibility: hidden;\\n}\\n.dial.in_control .dial__lbl--target {\\n  visibility: visible;\\n}\\n.dial.in_control .dial__lbl--low {\\n  visibility: visible;\\n}\\n.dial.in_control .dial__lbl--high {\\n  visibility: visible;\\n}\\n.in_control .dial__ico__settings {\\n  opacity: 1;\\n}\\n.dial__lbl--ambient {\\n  font-size: 120px;\\n  font-weight: bold;\\n  visibility: visible;\\n}\\n.dial.in_control.has_dual .dial__chevron--low,\\n.dial.in_control.has_dual .dial__chevron--high {\\n  visibility: visible;\\n}\\n.dial.in_control .dial__chevron--target {\\n  visibility: visible;\\n}\\n.dial.in_control.has_dual .dial__chevron--target {\\n  visibility: hidden;\\n}\\n.dial .dial__chevron {\\n  visibility: hidden;\\n  fill: none;\\n  stroke: var(--thermostat-text-color);\\n  stroke-width: 4px;\\n  opacity: 0.3;\\n}\\n.dial .dial__chevron.pressed {\\n  opacity: 1;\\n}\\n.dial.in_control .dial__lbl--ambient {\\n  visibility: hidden;\\n}\\n.dial__lbl--super--ambient, .dial__lbl--super--target {\\n  font-size: 40px;\\n  font-weight: bold;\\n}\\n.dial__lbl--super--high, .dial__lbl--super--low {\\n  font-size: 30px;\\n  font-weight: bold;\\n}\\n.dial__lbl--ring {\\n  font-size: 22px;\\n  font-weight: bold;\\n}\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack:///./src/thermostat.lib.css?./node_modules/css-loader");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n//# sourceURL=webpack:///./node_modules/css-loader/lib/css-base.js?");

/***/ }),

/***/ "./src/thermostat-card.js":
/*!********************************!*\
  !*** ./src/thermostat-card.js ***!
  \********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _thermostat_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./thermostat.lib */ \"./src/thermostat.lib.js\");\n\n\nclass ThermostatCard extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n  }\n  set hass(hass) {\n    const config = this._config;\n    const entity = hass.states[config.entity];\n    let hvac_state;\n    if (config.hvac.attribute)\n      hvac_state = entity.attributes[config.hvac.attribute];\n    else\n      hvac_state = entity.state;\n    const new_state = {\n      min_value: entity.attributes.min_temp,\n      max_value: entity.attributes.max_temp,\n      ambient_temperature: entity.attributes.current_temperature,\n      target_temperature: entity.attributes.temperature,\n      target_temperature_low: entity.attributes.target_temp_low,\n      target_temperature_high: entity.attributes.target_temp_high,\n      hvac_state: config.hvac.states[hvac_state] || 'off',\n      away: (entity.attributes.away_mode == 'on' ? true : false),\n    }\n\n    if (!this._saved_state ||\n      (this._saved_state.min_value != new_state.min_value ||\n        this._saved_state.max_value != new_state.max_value ||\n        this._saved_state.ambient_temperature != new_state.ambient_temperature ||\n        this._saved_state.target_temperature != new_state.target_temperature ||\n        this._saved_state.target_temperature_low != new_state.target_temperature_low ||\n        this._saved_state.target_temperature_high != new_state.target_temperature_high ||\n        this._saved_state.hvac_state != new_state.hvac_state ||\n        this._saved_state.away != new_state.away)) {\n      this._saved_state = new_state;\n      this.thermostat.updateState(new_state);\n    }\n    this._hass = hass;\n    // if (!this._controlsBuilt) this._buildControls(this._controls);\n  }\n\n  _controlSetPoints() {\n    if (this.thermostat.dual) {\n      if (this.thermostat.temperature.high != this._saved_state.target_temperature_high ||\n        this.thermostat.temperature.low != this._saved_state.target_temperature_low)\n        this._hass.callService('climate', 'set_temperature', {\n          entity_id: this._config.entity,\n          target_temp_high: this.thermostat.temperature.high,\n          target_temp_low: this.thermostat.temperature.low,\n        });\n    } else {\n      if (this.thermostat.temperature.target != this._saved_state.target_temperature)\n        this._hass.callService('climate', 'set_temperature', {\n          entity_id: this._config.entity,\n          temperature: this.thermostat.temperature.target,\n        });\n    }\n  }\n\n  setConfig(config) {\n    // Check config\n    if (!config.entity && config.entity.split(\".\")[0] === 'climate') {\n      throw new Error('Please define an entity');\n    }\n\n    // Cleanup DOM\n    const root = this.shadowRoot;\n    if (root.lastChild) root.removeChild(root.lastChild);\n    this._controlsBuilt = false;\n\n    // Prepare config defaults\n    const cardConfig = Object.assign({}, config);\n    cardConfig.hvac = Object.assign({}, config.hvac);\n    if (!cardConfig.diameter) cardConfig.diameter = 400;\n    if (!cardConfig.pending) cardConfig.pending = 3;\n    if (!cardConfig.idle_zone) cardConfig.idle_zone = 2;\n    if (!cardConfig.step) cardConfig.step = 0.5;\n    if (!cardConfig.highlight_tap) cardConfig.highlight_tap = false;\n    if (!cardConfig.no_card) cardConfig.no_card = false;\n    if (!cardConfig.chevron_size) cardConfig.chevron_size = 50;\n    if (!cardConfig.num_ticks) cardConfig.num_ticks = 150;\n    if (!cardConfig.tick_degrees) cardConfig.tick_degrees = 300;\n    if (!cardConfig.hvac.states) cardConfig.hvac.states = { 'off': 'off', 'heat': 'heat', 'cool': 'cool', };\n\n    // Extra config values generated for simplicity of updates\n    cardConfig.radius = cardConfig.diameter / 2;\n    cardConfig.ticks_outer_radius = cardConfig.diameter / 30;\n    cardConfig.ticks_inner_radius = cardConfig.diameter / 8;\n    cardConfig.offset_degrees = 180 - (360 - cardConfig.tick_degrees) / 2;\n    cardConfig.control = this._controlSetPoints.bind(this);\n    this.thermostat = new _thermostat_lib__WEBPACK_IMPORTED_MODULE_0__[\"default\"](cardConfig);\n    this._config = cardConfig;\n    if (cardConfig.no_card === true) {\n      root.appendChild(this.thermostat.container);\n    }\n    else {\n      const card = document.createElement('ha-card');\n      card.style.padding = '5%';\n      card.appendChild(this.thermostat.container);\n      root.appendChild(card);\n    }\n  }\n  _computeIcon(name) {\n    switch (name) {\n      case 'operation_mode':\n        return 'mdi:sync'\n      case 'swing_mode':\n        return 'mdi:cursor-move';\n      case 'fan_mode':\n        return 'mdi:fan';\n    }\n    return 'mdi:settings';\n  }\n\n  _buildControls(element) {\n    this._controlsBuilt = true;\n    const config = this._config;\n    const entity = this._hass.states[config.entity];\n    if (config.services) {\n      // controls\n      config.services.forEach(el => {\n        let content = '';\n        console.log(el.name);\n        content += `<ha-icon icon='${this._computeIcon(el.name)}' name='${el.name}'></ha-icon>`\n        // get all values\n        entity.attributes[el.values].forEach(el => {\n          content += `${el},`\n        })\n        content += '<br/>';\n        element.innerHTML += content;\n      });\n    }\n  }\n}\ncustomElements.define('thermostat-card', ThermostatCard);\n\n//# sourceURL=webpack:///./src/thermostat-card.js?");

/***/ }),

/***/ "./src/thermostat.lib.css":
/*!********************************!*\
  !*** ./src/thermostat.lib.css ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n        var result = __webpack_require__(/*! !../node_modules/css-loader!./thermostat.lib.css */ \"./node_modules/css-loader/index.js!./src/thermostat.lib.css\");\n\n        if (typeof result === \"string\") {\n            module.exports = result;\n        } else {\n            module.exports = result.toString();\n        }\n    \n\n//# sourceURL=webpack:///./src/thermostat.lib.css?");

/***/ }),

/***/ "./src/thermostat.lib.js":
/*!*******************************!*\
  !*** ./src/thermostat.lib.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ThermostatUI; });\n/* harmony import */ var _thermostat_lib_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./thermostat.lib.css */ \"./src/thermostat.lib.css\");\n/* harmony import */ var _thermostat_lib_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_thermostat_lib_css__WEBPACK_IMPORTED_MODULE_0__);\n\n\nclass ThermostatUI {\n  get container() {\n    return this._container\n  }\n  set dual(val) {\n    this._dual = val\n  }\n  get dual() {\n    return this._dual;\n  }\n  get in_control() {\n    return this._in_control;\n  }\n  get temperature() {\n    return {\n      low: this._low,\n      high: this._high,\n      target: this._target,\n    }\n  }\n  get ambient() {\n    return this._ambient;\n  }\n  set temperature(val) {\n    this._ambient = val.ambient;\n    this._low = val.low;\n    this._high = val.high;\n    this._target = val.target;\n    if (this._low && this._high) this.dual = true;\n  }\n  constructor(config) {\n    this._config = config; // need certain options for updates\n    this._ticks = []; // need for dynamic tick updates\n    this._controls = []; // need for managing highlight and clicks\n    this._dual = false; // by default is single temperature\n    this._container = document.createElement('div');\n    this._container.className = 'dial_container';\n    \n    const style = document.createElement('style');\n    style.textContent = _thermostat_lib_css__WEBPACK_IMPORTED_MODULE_0___default.a;\n    if (config.title) this._container.appendChild(this._buildTitle(config.title));\n    this._container.appendChild(style);\n    const root = this._buildCore(config.diameter);\n    root.appendChild(this._buildDial(config.radius));\n    root.appendChild(this._buildTicks(config.num_ticks));\n    root.appendChild(this._buildRing(config.radius));\n    root.appendChild(this._buildLeaf(config.radius));\n    root.appendChild(this._buildThermoIcon(config.radius));\n    root.appendChild(this._buildDialSlot(1));\n    root.appendChild(this._buildDialSlot(2));\n    root.appendChild(this._buildDialSlot(3));\n\n    root.appendChild(this._buildText(config.radius, 'ambient', 0));\n    root.appendChild(this._buildText(config.radius, 'target', 0));\n    root.appendChild(this._buildText(config.radius, 'low', -config.radius / 2.5));\n    root.appendChild(this._buildText(config.radius, 'high', config.radius / 3));\n    root.appendChild(this._buildChevrons(config.radius, 0, 'low', 0.7, -config.radius / 2.5));\n    root.appendChild(this._buildChevrons(config.radius, 0, 'high', 0.7, config.radius / 3));\n    root.appendChild(this._buildChevrons(config.radius, 0, 'target', 1, 0));\n    root.appendChild(this._buildChevrons(config.radius, 180, 'low', 0.7, -config.radius / 2.5));\n    root.appendChild(this._buildChevrons(config.radius, 180, 'high', 0.7, config.radius / 3));\n    root.appendChild(this._buildChevrons(config.radius, 180, 'target', 1, 0));\n    this._container.appendChild(root);\n    this._root = root;\n    this._buildControls(config.radius);\n    this._servicesControls = this._buildSettingsIcon(config.radius); // after build controls to catch 'click'\n    this._root.appendChild(this._servicesControls);\n    this._root.addEventListener('click', () => this._enableControls());\n    this._servicesControls.addEventListener('click', () => this._serviceControlClick());\n  }\n\n  updateState(options) {\n    const config = this._config;\n    const away = options.away || false;\n    this.min_value = options.min_value;\n    this.max_value = options.max_value;\n    this.hvac_state = options.hvac_state;\n    this.temperature = {\n      low: options.target_temperature_low,\n      high: options.target_temperature_high,\n      target: options.target_temperature,\n      ambient: options.ambient_temperature,\n    }\n\n    this._updateClass('has_dual', this.dual);\n    let tick_label, from, to;\n    const tick_indexes = [];\n    const ambient_index = SvgUtil.restrictToRange(Math.round((this.ambient - this.min_value) / (this.max_value - this.min_value) * config.num_ticks), 0, config.num_ticks - 1);\n    const target_index = SvgUtil.restrictToRange(Math.round((this._target - this.min_value) / (this.max_value - this.min_value) * config.num_ticks), 0, config.num_ticks - 1);\n    const high_index = SvgUtil.restrictToRange(Math.round((this._high - this.min_value) / (this.max_value - this.min_value) * config.num_ticks), 0, config.num_ticks - 1);\n    const low_index = SvgUtil.restrictToRange(Math.round((this._low - this.min_value) / (this.max_value - this.min_value) * config.num_ticks), 0, config.num_ticks - 1);\n    if (!this.dual) {\n      tick_label = [this._target, this.ambient].sort();\n      this._updateTemperatureSlot(tick_label[0], -8, `temperature_slot_1`);\n      this._updateTemperatureSlot(tick_label[1], 8, `temperature_slot_2`);\n      switch (this.hvac_state) {\n        case 'cool':\n          // active ticks\n          if (target_index < ambient_index) {\n            from = target_index;\n            to = ambient_index;\n          }\n          break;\n        case 'heat':\n          // active ticks\n          if (target_index > ambient_index) {\n            from = ambient_index;\n            to = target_index;\n          }\n          break;\n        default:\n      }\n    } else {\n      tick_label = [this._low, this._high, this.ambient].sort();\n      this._updateTemperatureSlot(null, 0, `temperature_slot_1`);\n      this._updateTemperatureSlot(null, 0, `temperature_slot_2`);\n      this._updateTemperatureSlot(null, 0, `temperature_slot_3`);\n      switch (this.hvac_state) {\n        case 'cool':\n          // active ticks\n          if (high_index < ambient_index) {\n            from = high_index;\n            to = ambient_index;\n            this._updateTemperatureSlot(this.ambient, 8, `temperature_slot_3`);\n            this._updateTemperatureSlot(this._high, -8, `temperature_slot_2`);\n          }\n          break;\n        case 'heat':\n          // active ticks\n          if (low_index > ambient_index) {\n            from = ambient_index;\n            to = low_index;\n            this._updateTemperatureSlot(this.ambient, -8, `temperature_slot_1`);\n            this._updateTemperatureSlot(this._low, 8, `temperature_slot_2`);\n          }\n          break;\n        case 'off':\n          // active ticks\n          if (high_index < ambient_index) {\n            from = high_index;\n            to = ambient_index;\n            this._updateTemperatureSlot(this.ambient, 8, `temperature_slot_3`);\n            this._updateTemperatureSlot(this._high, -8, `temperature_slot_2`);\n          }\n          if (low_index > ambient_index) {\n            from = ambient_index;\n            to = low_index;\n            this._updateTemperatureSlot(this.ambient, -8, `temperature_slot_1`);\n            this._updateTemperatureSlot(this._low, 8, `temperature_slot_2`);\n          }\n          break;\n        default:\n      }\n    }\n    tick_label.forEach(item => tick_indexes.push(SvgUtil.restrictToRange(Math.round((item - this.min_value) / (this.max_value - this.min_value) * config.num_ticks), 0, config.num_ticks - 1)));\n    this._updateTicks(from, to, tick_indexes);\n    this._updateClass('has-leaf', away);\n    this._updateHvacState();\n    this._updateText('ambient', this.ambient);\n    this._updateEdit(false);\n    this._updateClass('has-thermo', false);\n  }\n\n  _serviceControlClick() {\n    console.log('Switching views');\n  }\n\n  _temperatureControlClicked(index) {\n    const config = this._config;\n    let chevron;\n    this._root.querySelectorAll('path.dial__chevron').forEach(el => SvgUtil.setClass(el, 'pressed', false));\n    if (this.in_control) {\n      if (this.dual) {\n        switch (index) {\n          case 0:\n            // clicked top left \n            chevron = this._root.querySelectorAll('path.dial__chevron--low')[1];\n            this._low = this._low + config.step;\n            if ((this._low + config.idle_zone) >= this._high) this._low = this._high - config.idle_zone;\n            break;\n          case 1:\n            // clicked top right\n            chevron = this._root.querySelectorAll('path.dial__chevron--high')[1];\n            this._high = this._high + config.step;\n            if (this._high > this.max_value) this._high = this.max_value;\n            break;\n          case 2:\n            // clicked bottom right\n            chevron = this._root.querySelectorAll('path.dial__chevron--high')[0];\n            this._high = this._high - config.step;\n            if ((this._high - config.idle_zone) <= this._low) this._high = this._low + config.idle_zone;\n            break;\n          case 3:\n            // clicked bottom left\n            chevron = this._root.querySelectorAll('path.dial__chevron--low')[0];\n            this._low = this._low - config.step;\n            if (this._low < this.min_value) this._low = this.min_value;\n            break;\n        }\n        SvgUtil.setClass(chevron, 'pressed', true);\n        setTimeout(() => SvgUtil.setClass(chevron, 'pressed', false), 200);\n        if (config.highlight_tap)\n          SvgUtil.setClass(this._controls[index], 'control-visible', true);\n      }\n      else {\n        if (index < 2) {\n          // clicked top\n          chevron = this._root.querySelectorAll('path.dial__chevron--target')[1];\n          this._target = this._target + config.step;\n          if (this._target > this.max_value) this._target = this.max_value;\n          if (config.highlight_tap) {\n            SvgUtil.setClass(this._controls[0], 'control-visible', true);\n            SvgUtil.setClass(this._controls[1], 'control-visible', true);\n          }\n        } else {\n          // clicked bottom\n          chevron = this._root.querySelectorAll('path.dial__chevron--target')[0];\n          this._target = this._target - config.step;\n          if (this._target < this.min_value) this._target = this.min_value;\n          if (config.highlight_tap) {\n            SvgUtil.setClass(this._controls[2], 'control-visible', true);\n            SvgUtil.setClass(this._controls[3], 'control-visible', true);\n          }\n        }\n        SvgUtil.setClass(chevron, 'pressed', true);\n        setTimeout(() => SvgUtil.setClass(chevron, 'pressed', false), 200);\n      }\n      if (config.highlight_tap) {\n        setTimeout(() => {\n          SvgUtil.setClass(this._controls[0], 'control-visible', false);\n          SvgUtil.setClass(this._controls[1], 'control-visible', false);\n          SvgUtil.setClass(this._controls[2], 'control-visible', false);\n          SvgUtil.setClass(this._controls[3], 'control-visible', false);\n        }, 200);\n      }\n    } else {\n      this._enableControls();\n    }\n  }\n\n  _updateEdit(show_edit) {\n    SvgUtil.setClass(this._root, 'dial--edit', show_edit);\n  }\n\n  _enableControls() {\n    const config = this._config;\n    this._in_control = true;\n    this._updateClass('in_control', this.in_control);\n    if (this._timeoutHandler) clearTimeout(this._timeoutHandler);\n    this._updateEdit(true);\n    this._updateClass('has-thermo', true);\n    this._updateText('target', this.temperature.target);\n    this._updateText('low', this.temperature.low);\n    this._updateText('high', this.temperature.high);\n    this._timeoutHandler = setTimeout(() => {\n      this._updateText('ambient', this.ambient);\n      this._updateEdit(false);\n      this._updateClass('has-thermo', false);\n      this._in_control = false;\n      this._updateClass('in_control', this.in_control);\n      config.control();\n    }, config.pending * 1000);\n  }\n\n  _updateClass(class_name, flag) {\n    SvgUtil.setClass(this._root, class_name, flag);\n    SvgUtil.setClass(this.container, class_name, flag);\n  }\n\n  _updateText(id, value) {\n    const lblTarget = this._root.querySelector(`#${id}`).querySelectorAll('tspan');\n    const text = Math.floor(value);\n    if (value) {\n      lblTarget[0].textContent = text;\n      if (value % 1 != 0) {\n        const fraction = Math.ceil(((value < 1.0) ? value : (value % Math.floor(value))) * 10)\n        lblTarget[1].textContent = `${fraction}`;\n      } else {\n        lblTarget[1].textContent = '';\n      }\n    }\n  }\n\n  _updateTemperatureSlot(value, offset, slot) {\n    const config = this._config;\n    const lblSlot1 = this._root.querySelector(`#${slot}`)\n    lblSlot1.textContent = value != null ? SvgUtil.superscript(value) : '';\n    const peggedValue = SvgUtil.restrictToRange(value, this.min_value, this.max_value);\n    const position = [config.radius, config.ticks_outer_radius - (config.ticks_outer_radius - config.ticks_inner_radius) / 2];\n    let degs = config.tick_degrees * (peggedValue - this.min_value) / (this.max_value - this.min_value) - config.offset_degrees + offset;\n    const pos = SvgUtil.rotatePoint(position, degs, [config.radius, config.radius]);\n    SvgUtil.attributes(lblSlot1, {\n      x: pos[0],\n      y: pos[1]\n    });\n  }\n\n  _updateHvacState() {\n    this._root.classList.forEach(c => {\n      if (c.indexOf('dial--state--') != -1)\n        this._root.classList.remove(c);\n    });\n    this._root.classList.add('dial--state--' + this.hvac_state);\n  }\n\n  _updateTicks(from, to, large_ticks) {\n    const config = this._config;\n\n    const tickPoints = [\n      [config.radius - 1, config.ticks_outer_radius],\n      [config.radius + 1, config.ticks_outer_radius],\n      [config.radius + 1, config.ticks_inner_radius],\n      [config.radius - 1, config.ticks_inner_radius]\n    ];\n    const tickPointsLarge = [\n      [config.radius - 1.5, config.ticks_outer_radius],\n      [config.radius + 1.5, config.ticks_outer_radius],\n      [config.radius + 1.5, config.ticks_inner_radius + 20],\n      [config.radius - 1.5, config.ticks_inner_radius + 20]\n    ];\n\n    this._ticks.forEach((tick, index) => {\n      let isLarge = false;\n      let isActive = (index >= from && index <= to) ? 'active' : '';\n      large_ticks.forEach(i => isLarge = isLarge || (index == i));\n      if (isLarge) isActive += ' large';\n      const theta = config.tick_degrees / config.num_ticks;\n      SvgUtil.attributes(tick, {\n        d: SvgUtil.pointsToPath(SvgUtil.rotatePoints(isLarge ? tickPointsLarge : tickPoints, index * theta - config.offset_degrees, [config.radius, config.radius])),\n        class: isActive\n      });\n    });\n  }\n\n  _buildCore(diameter) {\n    return SvgUtil.createSVGElement('svg', {\n      width: '100%',\n      height: '100%',\n      viewBox: '0 0 ' + diameter + ' ' + diameter,\n      class: 'dial'\n    })\n  }\n\n  _buildTitle(title) {\n    const lblTitle = document.createElement('div');\n    lblTitle.className = 'dial_title';\n    lblTitle.textContent = title;\n    return lblTitle;\n  }\n\n  // build black dial\n  _buildDial(radius) {\n    return SvgUtil.createSVGElement('circle', {\n      cx: radius,\n      cy: radius,\n      r: radius,\n      class: 'dial__shape'\n    })\n  }\n  // build circle around\n  _buildRing(radius) {\n    return SvgUtil.createSVGElement('path', {\n      d: SvgUtil.donutPath(radius, radius, radius - 4, radius - 8),\n      class: 'dial__editableIndicator',\n    })\n  }\n\n  _buildTicks(num_ticks) {\n    const tick_element = SvgUtil.createSVGElement('g', {\n      class: 'dial__ticks'\n    });\n    for (let i = 0; i < num_ticks; i++) {\n      const tick = SvgUtil.createSVGElement('path', {})\n      this._ticks.push(tick);\n      tick_element.appendChild(tick);\n    }\n    return tick_element;\n  }\n\n  _buildLeaf(radius) {\n    const leafScale = radius / 5 / 100;\n    const leafDef = [\"M\", 3, 84, \"c\", 24, 17, 51, 18, 73, -6, \"C\", 100, 52,\n      100, 22, 100, 4, \"c\", -13, 15, -37, 9, -70, 19, \"C\", 4, 32, 0, 63, 0,\n      76, \"c\", 6, -7, 18, -17, 33, -23, 24, -9, 34, -9, 48, -20, -9, 10,\n      -20, 16, -43, 24, \"C\", 22, 63, 8, 78, 3, 84, \"z\"].map((x) => isNaN(x) ? x : x * leafScale).join(' ');\n    const translate = [radius - (leafScale * 100 * 0.5), radius * 1.5]\n    return SvgUtil.createSVGElement('path', {\n      class: 'dial__ico__leaf',\n      d: leafDef,\n      transform: 'translate(' + translate[0] + ',' + translate[1] + ')'\n    });\n  }\n\n  _buildChevrons(radius, rotation, id, scale, offset) {\n    const config = this._config;\n    const translation = rotation > 0 ? -1 : 1;\n    const width = config.chevron_size;\n    const chevron_def = [\"M\", 0, 0, \"L\", width / 2, width * 0.3, \"L\", width, 0].map((x) => isNaN(x) ? x : x * scale).join(' ');\n    const translate = [radius - width / 2 * scale * translation + offset, radius + 70 * scale * 1.1 * translation];\n    const chevron = SvgUtil.createSVGElement('path', {\n      class: `dial__chevron dial__chevron--${id}`,\n      d: chevron_def,\n      transform: `translate(${translate[0]},${translate[1]}) rotate(${rotation})`\n    });\n    return chevron;\n  }\n\n  _buildThermoIcon(radius) {\n    const thermoScale = radius / 3 / 100;\n    const thermoDef = 'M 37.999 38.261 V 7 c 0 -3.859 -3.141 -7 -7 -7 s -7 3.141 -7 7 v 31.261 c -3.545 2.547 -5.421 6.769 -4.919 11.151 c 0.629 5.482 5.066 9.903 10.551 10.512 c 0.447 0.05 0.895 0.074 1.339 0.074 c 2.956 0 5.824 -1.08 8.03 -3.055 c 2.542 -2.275 3.999 -5.535 3.999 -8.943 C 42.999 44.118 41.14 40.518 37.999 38.261 Z M 37.666 55.453 c -2.146 1.921 -4.929 2.8 -7.814 2.482 c -4.566 -0.506 -8.261 -4.187 -8.785 -8.752 c -0.436 -3.808 1.28 -7.471 4.479 -9.56 l 0.453 -0.296 V 38 h 1 c 0.553 0 1 -0.447 1 -1 s -0.447 -1 -1 -1 h -1 v -3 h 1 c 0.553 0 1 -0.447 1 -1 s -0.447 -1 -1 -1 h -1 v -3 h 1 c 0.553 0 1 -0.447 1 -1 s -0.447 -1 -1 -1 h -1 v -3 h 1 c 0.553 0 1 -0.447 1 -1 s -0.447 -1 -1 -1 h -1 v -3 h 1 c 0.553 0 1 -0.447 1 -1 s -0.447 -1 -1 -1 h -1 v -3 h 1 c 0.553 0 1 -0.447 1 -1 s -0.447 -1 -1 -1 h -1 V 8 h 1 c 0.553 0 1 -0.447 1 -1 s -0.447 -1 -1 -1 H 26.1 c 0.465 -2.279 2.484 -4 4.899 -4 c 2.757 0 5 2.243 5 5 v 1 h -1 c -0.553 0 -1 0.447 -1 1 s 0.447 1 1 1 h 1 v 3 h -1 c -0.553 0 -1 0.447 -1 1 s 0.447 1 1 1 h 1 v 3 h -1 c -0.553 0 -1 0.447 -1 1 s 0.447 1 1 1 h 1 v 3 h -1 c -0.553 0 -1 0.447 -1 1 s 0.447 1 1 1 h 1 v 3 h -1 c -0.553 0 -1 0.447 -1 1 s 0.447 1 1 1 h 1 v 3 h -1 c -0.553 0 -1 0.447 -1 1 s 0.447 1 1 1 h 1 v 4.329 l 0.453 0.296 c 2.848 1.857 4.547 4.988 4.547 8.375 C 40.999 50.841 39.784 53.557 37.666 55.453 Z'.split(' ').map((x) => isNaN(x) ? x : x * thermoScale).join(' ');\n    const translate = [radius - (thermoScale * 100 * 0.3), radius * 1.65]\n    return SvgUtil.createSVGElement('path', {\n      class: 'dial__ico__thermo',\n      d: thermoDef,\n      transform: 'translate(' + translate[0] + ',' + translate[1] + ')'\n    });\n  }\n\n  _buildDialSlot(index) {\n    return SvgUtil.createSVGElement('text', {\n      class: 'dial__lbl dial__lbl--ring',\n      id: `temperature_slot_${index}`\n    })\n  }\n\n  _buildText(radius, name, offset) {\n    const target = SvgUtil.createSVGElement('text', {\n      x: radius + offset,\n      y: radius,\n      class: `dial__lbl dial__lbl--${name}`,\n      id: name\n    });\n    const text = SvgUtil.createSVGElement('tspan', {\n    });\n    // hack\n    if (name == 'target' || name == 'ambient') offset += 20;\n    const superscript = SvgUtil.createSVGElement('tspan', {\n      x: radius + radius / 3.1 + offset,\n      y: radius - radius / 6,\n      class: `dial__lbl--super--${name}`\n    });\n    target.appendChild(text);\n    target.appendChild(superscript);\n    return target;\n  }\n\n  _buildControls(radius) {\n    let startAngle = 270;\n    let loop = 4;\n    for (let index = 0; index < loop; index++) {\n      const angle = 360 / loop;\n      const sector = SvgUtil.anglesToSectors(radius, startAngle, angle);\n      const controlsDef = 'M' + sector.L + ',' + sector.L + ' L' + sector.L + ',0 A' + sector.L + ',' + sector.L + ' 1 0,1 ' + sector.X + ', ' + sector.Y + ' z';\n      const path = SvgUtil.createSVGElement('path', {\n        class: 'dial__temperatureControl',\n        d: controlsDef,\n        transform: 'rotate(' + sector.R + ', ' + sector.L + ', ' + sector.L + ')'\n      });\n      this._controls.push(path);\n      path.addEventListener('click', () => this._temperatureControlClicked(index));\n      this._root.appendChild(path);\n      startAngle = startAngle + angle;\n    }\n  }\n\n  _buildSettingsIcon(radius) {\n    const thermoScale = Math.ceil(radius / 100);\n    const iconDef = `M 3 17 V 19 H 9 V 17 H 3 M 3 5 V 7 H 13 V 5 H 3 M 13 21 V 19 H 21 V 17 H 13 V 15 H 11 V 21 H 13 M 7 9 V 11 H 3 V 13 H 7 V 15 H 9 V 9 H 7 M 21 13 V 11 H 11 V 13 H 21 M 15 9 H 17 V 7 H 21 V 5 H 17 V 3 H 15 V 9 Z`.split(' ').map((x) => isNaN(x) ? x : x * thermoScale).join(' ');\n    return SvgUtil.createSVGElement('path', {\n      class: 'dial__ico__settings',\n      d: iconDef,\n      transform: `translate(${radius * 2 - 30 * thermoScale}, ${5 * thermoScale})`\n    });\n  }\n}\n\nclass SvgUtil {\n  static createSVGElement(tag, attributes) {\n    const element = document.createElementNS('http://www.w3.org/2000/svg', tag);\n    this.attributes(element, attributes)\n    return element;\n  }\n  static attributes(element, attrs) {\n    for (let i in attrs) {\n      element.setAttribute(i, attrs[i]);\n    }\n  }\n  // Rotate a cartesian point about given origin by X degrees\n  static rotatePoint(point, angle, origin) {\n    const radians = angle * Math.PI / 180;\n    const x = point[0] - origin[0];\n    const y = point[1] - origin[1];\n    const x1 = x * Math.cos(radians) - y * Math.sin(radians) + origin[0];\n    const y1 = x * Math.sin(radians) + y * Math.cos(radians) + origin[1];\n    return [x1, y1];\n  }\n  // Rotate an array of cartesian points about a given origin by X degrees\n  static rotatePoints(points, angle, origin) {\n    return points.map((point) => this.rotatePoint(point, angle, origin));\n  }\n  // Given an array of points, return an SVG path string representing the shape they define\n  static pointsToPath(points) {\n    return points.map((point, iPoint) => (iPoint > 0 ? 'L' : 'M') + point[0] + ' ' + point[1]).join(' ') + 'Z';\n  }\n  static circleToPath(cx, cy, r) {\n    return [\n      \"M\", cx, \",\", cy,\n      \"m\", 0 - r, \",\", 0,\n      \"a\", r, \",\", r, 0, 1, \",\", 0, r * 2, \",\", 0,\n      \"a\", r, \",\", r, 0, 1, \",\", 0, 0 - r * 2, \",\", 0,\n      \"z\"\n    ].join(' ').replace(/\\s,\\s/g, \",\");\n  }\n  static donutPath(cx, cy, rOuter, rInner) {\n    return this.circleToPath(cx, cy, rOuter) + \" \" + this.circleToPath(cx, cy, rInner);\n  }\n\n  static superscript(number) {\n    return `${Math.floor(number)}${number % 1 != 0 ? '⁵' : ''}`;\n  }\n\n  // Restrict a number to a min + max range\n  static restrictToRange(val, min, max) {\n    if (val < min) return min;\n    if (val > max) return max;\n    return val;\n  }\n  static setClass(el, className, state) {\n    el.classList[state ? 'add' : 'remove'](className);\n  }\n\n  static anglesToSectors(radius, startAngle, angle) {\n    let aRad = 0 // Angle in Rad\n    let z = 0 // Size z\n    let x = 0 // Side x\n    let X = 0 // SVG X coordinate\n    let Y = 0 // SVG Y coordinate\n    const aCalc = (angle > 180) ? 360 - angle : angle;\n    aRad = aCalc * Math.PI / 180;\n    z = Math.sqrt(2 * radius * radius - (2 * radius * radius * Math.cos(aRad)));\n    if (aCalc <= 90) {\n      x = radius * Math.sin(aRad);\n    }\n    else {\n      x = radius * Math.sin((180 - aCalc) * Math.PI / 180);\n    }\n    Y = Math.sqrt(z * z - x * x);\n    if (angle <= 180) {\n      X = radius + x;\n    }\n    else {\n      X = radius - x;\n    }\n    return {\n      L: radius,\n      X: X,\n      Y: Y,\n      R: startAngle\n    }\n  }\n}\n\n//# sourceURL=webpack:///./src/thermostat.lib.js?");

/***/ })

/******/ });